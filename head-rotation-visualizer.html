<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Head Rotation Visualizer | Pitch, Yaw, Roll</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
            background: #0B1E33;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
        }

        /* Axis Labels */
        .axis-label {
            position: absolute;
            font-size: 14px;
            font-weight: 600;
            padding: 4px 12px;
            border-radius: 4px;
            pointer-events: none;
            text-transform: uppercase;
            letter-spacing: 1px;
            backdrop-filter: blur(4px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        #pitch-label {
            color: #ff6b6b;
            background: rgba(255, 107, 107, 0.15);
            border-color: rgba(255, 107, 107, 0.3);
        }

        #yaw-label {
            color: #69db7c;
            background: rgba(105, 219, 124, 0.15);
            border-color: rgba(105, 219, 124, 0.3);
        }

        #roll-label {
            color: #74c0fc;
            background: rgba(116, 192, 252, 0.15);
            border-color: rgba(116, 192, 252, 0.3);
        }

        /* Info Panel */
        #info-panel {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(11, 30, 51, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(66, 227, 245, 0.2);
            border-radius: 12px;
            padding: 16px 24px;
            color: #fff;
            text-align: center;
        }

        #info-panel h3 {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: #42E3F5;
            margin-bottom: 8px;
        }

        #info-panel p {
            font-size: 13px;
            color: rgba(255, 255, 255, 0.7);
        }

        /* Custom lil-gui styling */
        .lil-gui {
            --background-color: rgba(11, 30, 51, 0.95) !important;
            --title-background-color: rgba(66, 227, 245, 0.2) !important;
            --title-text-color: #42E3F5 !important;
            --widget-color: rgba(66, 227, 245, 0.3) !important;
            --hover-color: rgba(66, 227, 245, 0.4) !important;
            --focus-color: #42E3F5 !important;
            --number-color: #42E3F5 !important;
            --string-color: #42E3F5 !important;
            font-family: 'Segoe UI', system-ui, sans-serif !important;
        }
    </style>
</head>

<body>
    <div id="canvas-container"></div>

    <!-- Axis Labels -->
    <div id="pitch-label" class="axis-label">Pitch (X)</div>
    <div id="yaw-label" class="axis-label">Yaw (Y)</div>
    <div id="roll-label" class="axis-label">Roll (Z)</div>

    <!-- Info Panel -->
    <div id="info-panel">
        <h3>Head Rotation Axes</h3>
        <p>Use the controls to rotate the head along Pitch, Yaw, and Roll axes</p>
    </div>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- lil-gui -->
    <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.19/dist/lil-gui.umd.min.js"></script>

    <script>
        // ============================================
        // CONFIGURATION
        // ============================================
        const CONFIG = {
            bgColor: 0x0B1E33,
            wireColor: 0x42E3F5,
            axisLength: 2.5,
            damping: 0.08, // Smooth rotation damping
            headRadius: 1.2,
            headSegments: 12
        };

        // ============================================
        // SCENE SETUP
        // ============================================
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(CONFIG.bgColor);

        // Camera
        const camera = new THREE.PerspectiveCamera(
            50,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(4, 3, 5);
        camera.lookAt(0, 0, 0);

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        // ============================================
        // HEAD GROUP (contains all head elements)
        // ============================================
        const headGroup = new THREE.Group();
        scene.add(headGroup);

        // Create wireframe head (low-poly sphere)
        const headGeometry = new THREE.SphereGeometry(
            CONFIG.headRadius,
            CONFIG.headSegments,
            CONFIG.headSegments
        );

        // Scale to make it more head-shaped (taller, slightly narrower)
        headGeometry.scale(0.85, 1.1, 0.9);

        const wireframeMaterial = new THREE.MeshBasicMaterial({
            color: CONFIG.wireColor,
            wireframe: true,
            transparent: true,
            opacity: 0.8
        });

        const headMesh = new THREE.Mesh(headGeometry, wireframeMaterial);
        headGroup.add(headMesh);

        // Nose indicator (cone pointing forward)
        const noseGeometry = new THREE.ConeGeometry(0.15, 0.5, 8);
        const noseMaterial = new THREE.MeshBasicMaterial({
            color: CONFIG.wireColor,
            wireframe: true
        });
        const nose = new THREE.Mesh(noseGeometry, noseMaterial);
        nose.rotation.x = Math.PI / 2;
        nose.position.z = CONFIG.headRadius * 0.9 + 0.25;
        headGroup.add(nose);

        // Eyes (small circles)
        const eyeGeometry = new THREE.RingGeometry(0.08, 0.12, 16);
        const eyeMaterial = new THREE.MeshBasicMaterial({
            color: CONFIG.wireColor,
            side: THREE.DoubleSide
        });

        const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
        leftEye.position.set(-0.35, 0.2, CONFIG.headRadius * 0.85);
        headGroup.add(leftEye);

        const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
        rightEye.position.set(0.35, 0.2, CONFIG.headRadius * 0.85);
        headGroup.add(rightEye);

        // ============================================
        // AXIS HELPERS
        // ============================================
        const axisGroup = new THREE.Group();
        scene.add(axisGroup);

        // Create custom axis lines with arrows
        function createAxis(color, direction, length) {
            const group = new THREE.Group();

            // Line
            const points = [
                new THREE.Vector3(0, 0, 0),
                direction.clone().multiplyScalar(length)
            ];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({
                color: color,
                linewidth: 2
            });
            const line = new THREE.Line(geometry, material);
            group.add(line);

            // Arrow head (cone)
            const arrowGeo = new THREE.ConeGeometry(0.08, 0.25, 8);
            const arrowMat = new THREE.MeshBasicMaterial({ color: color });
            const arrow = new THREE.Mesh(arrowGeo, arrowMat);

            // Position and orient arrow
            arrow.position.copy(direction.clone().multiplyScalar(length));

            // Rotate arrow to point along axis
            if (direction.x !== 0) {
                arrow.rotation.z = -Math.PI / 2 * Math.sign(direction.x);
            } else if (direction.y !== 0) {
                arrow.rotation.z = direction.y > 0 ? 0 : Math.PI;
            } else if (direction.z !== 0) {
                arrow.rotation.x = Math.PI / 2 * Math.sign(direction.z);
            }

            group.add(arrow);

            // Negative side (dotted effect via shorter line)
            const negPoints = [
                new THREE.Vector3(0, 0, 0),
                direction.clone().multiplyScalar(-length * 0.5)
            ];
            const negGeo = new THREE.BufferGeometry().setFromPoints(negPoints);
            const negMat = new THREE.LineDashedMaterial({
                color: color,
                dashSize: 0.1,
                gapSize: 0.1,
                transparent: true,
                opacity: 0.4
            });
            const negLine = new THREE.Line(negGeo, negMat);
            negLine.computeLineDistances();
            group.add(negLine);

            return group;
        }

        // X-Axis (Pitch) - Red
        const xAxis = createAxis(0xff6b6b, new THREE.Vector3(1, 0, 0), CONFIG.axisLength);
        axisGroup.add(xAxis);

        // Y-Axis (Yaw) - Green
        const yAxis = createAxis(0x69db7c, new THREE.Vector3(0, 1, 0), CONFIG.axisLength);
        axisGroup.add(yAxis);

        // Z-Axis (Roll) - Blue
        const zAxis = createAxis(0x74c0fc, new THREE.Vector3(0, 0, 1), CONFIG.axisLength);
        axisGroup.add(zAxis);

        // Grid helper (subtle)
        const gridHelper = new THREE.GridHelper(8, 16, 0x1a4a6e, 0x0d2840);
        gridHelper.position.y = -2;
        scene.add(gridHelper);

        // ============================================
        // ROTATION STATE & GUI
        // ============================================
        const rotationState = {
            pitch: 0,  // X-axis rotation (degrees)
            yaw: 0,    // Y-axis rotation (degrees)
            roll: 0,   // Z-axis rotation (degrees)
            autoRotate: false
        };

        // Target rotation (for smooth interpolation)
        const targetRotation = { pitch: 0, yaw: 0, roll: 0 };

        // lil-gui setup
        const gui = new lil.GUI({ title: 'ðŸŽ® Head Rotation Controls' });

        gui.add(rotationState, 'pitch', -90, 90, 1)
            .name('Pitch (X) Â°')
            .onChange(val => targetRotation.pitch = THREE.MathUtils.degToRad(val));

        gui.add(rotationState, 'yaw', -180, 180, 1)
            .name('Yaw (Y) Â°')
            .onChange(val => targetRotation.yaw = THREE.MathUtils.degToRad(val));

        gui.add(rotationState, 'roll', -90, 90, 1)
            .name('Roll (Z) Â°')
            .onChange(val => targetRotation.roll = THREE.MathUtils.degToRad(val));

        gui.add(rotationState, 'autoRotate').name('Auto Rotate');

        // Reset button
        gui.add({
            reset: () => {
                rotationState.pitch = 0;
                rotationState.yaw = 0;
                rotationState.roll = 0;
                targetRotation.pitch = 0;
                targetRotation.yaw = 0;
                targetRotation.roll = 0;
                gui.controllers.forEach(c => c.updateDisplay());
            }
        }, 'reset').name('Reset All');

        // ============================================
        // LABEL POSITIONING
        // ============================================
        const pitchLabel = document.getElementById('pitch-label');
        const yawLabel = document.getElementById('yaw-label');
        const rollLabel = document.getElementById('roll-label');

        function updateLabels() {
            // Project 3D positions to 2D screen coordinates
            const pitchPos = new THREE.Vector3(CONFIG.axisLength + 0.3, 0, 0);
            const yawPos = new THREE.Vector3(0, CONFIG.axisLength + 0.3, 0);
            const rollPos = new THREE.Vector3(0, 0, CONFIG.axisLength + 0.3);

            [pitchPos, yawPos, rollPos].forEach(pos => pos.project(camera));

            const widthHalf = window.innerWidth / 2;
            const heightHalf = window.innerHeight / 2;

            pitchLabel.style.left = (pitchPos.x * widthHalf + widthHalf) + 'px';
            pitchLabel.style.top = (-pitchPos.y * heightHalf + heightHalf) + 'px';

            yawLabel.style.left = (yawPos.x * widthHalf + widthHalf) + 'px';
            yawLabel.style.top = (-yawPos.y * heightHalf + heightHalf) + 'px';

            rollLabel.style.left = (rollPos.x * widthHalf + widthHalf) + 'px';
            rollLabel.style.top = (-rollPos.y * heightHalf + heightHalf) + 'px';
        }

        // ============================================
        // ANIMATION LOOP
        // ============================================
        let time = 0;

        function animate() {
            requestAnimationFrame(animate);
            time += 0.016;

            // Auto rotation
            if (rotationState.autoRotate) {
                rotationState.yaw = Math.sin(time * 0.5) * 45;
                rotationState.pitch = Math.sin(time * 0.3) * 20;
                targetRotation.yaw = THREE.MathUtils.degToRad(rotationState.yaw);
                targetRotation.pitch = THREE.MathUtils.degToRad(rotationState.pitch);
                gui.controllers.forEach(c => c.updateDisplay());
            }

            // Smooth damping interpolation
            headGroup.rotation.x += (targetRotation.pitch - headGroup.rotation.x) * CONFIG.damping;
            headGroup.rotation.y += (targetRotation.yaw - headGroup.rotation.y) * CONFIG.damping;
            headGroup.rotation.z += (targetRotation.roll - headGroup.rotation.z) * CONFIG.damping;

            // Update label positions
            updateLabels();

            renderer.render(scene, camera);
        }

        // ============================================
        // ORBIT CONTROLS (Simple mouse drag)
        // ============================================
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        const cameraRadius = camera.position.length();
        let cameraTheta = Math.atan2(camera.position.x, camera.position.z);
        let cameraPhi = Math.acos(camera.position.y / cameraRadius);

        container.addEventListener('mousedown', (e) => {
            if (e.button === 0) { // Left click
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            }
        });

        window.addEventListener('mousemove', (e) => {
            if (!isDragging) return;

            const deltaX = e.clientX - previousMousePosition.x;
            const deltaY = e.clientY - previousMousePosition.y;

            cameraTheta -= deltaX * 0.005;
            cameraPhi += deltaY * 0.005;

            // Clamp phi to prevent flipping
            cameraPhi = Math.max(0.1, Math.min(Math.PI - 0.1, cameraPhi));

            camera.position.x = cameraRadius * Math.sin(cameraPhi) * Math.sin(cameraTheta);
            camera.position.y = cameraRadius * Math.cos(cameraPhi);
            camera.position.z = cameraRadius * Math.sin(cameraPhi) * Math.cos(cameraTheta);

            camera.lookAt(0, 0, 0);

            previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        window.addEventListener('mouseup', () => {
            isDragging = false;
        });

        // Zoom with scroll
        container.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomSpeed = 0.001;
            const newRadius = cameraRadius * (1 + e.deltaY * zoomSpeed);
            const clampedRadius = Math.max(3, Math.min(15, newRadius));

            const scale = clampedRadius / camera.position.length();
            camera.position.multiplyScalar(scale);
        }, { passive: false });

        // ============================================
        // RESPONSIVE RESIZE
        // ============================================
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ============================================
        // START
        // ============================================
        animate();
        updateLabels();

        console.log('%cðŸŽ® Head Rotation Visualizer Loaded', 'color: #42E3F5; font-size: 14px; font-weight: bold;');
        console.log('Drag with mouse to orbit camera. Use sliders to rotate the head.');
    </script>
</body>

</html>